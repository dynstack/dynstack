// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `hotstorage_model.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub Id: i32,
    pub Release: ::protobuf::SingularPtrField<TimeStamp>,
    pub Due: ::protobuf::SingularPtrField<TimeStamp>,
    pub Ready: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // .DynStacking.HotStorage.DataModel.TimeStamp Release = 2;


    pub fn get_Release(&self) -> &TimeStamp {
        self.Release.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Release(&mut self) {
        self.Release.clear();
    }

    pub fn has_Release(&self) -> bool {
        self.Release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Release(&mut self, v: TimeStamp) {
        self.Release = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Release(&mut self) -> &mut TimeStamp {
        if self.Release.is_none() {
            self.Release.set_default();
        }
        self.Release.as_mut().unwrap()
    }

    // Take field
    pub fn take_Release(&mut self) -> TimeStamp {
        self.Release.take().unwrap_or_else(|| TimeStamp::new())
    }

    // .DynStacking.HotStorage.DataModel.TimeStamp Due = 3;


    pub fn get_Due(&self) -> &TimeStamp {
        self.Due.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Due(&mut self) {
        self.Due.clear();
    }

    pub fn has_Due(&self) -> bool {
        self.Due.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Due(&mut self, v: TimeStamp) {
        self.Due = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Due(&mut self) -> &mut TimeStamp {
        if self.Due.is_none() {
            self.Due.set_default();
        }
        self.Due.as_mut().unwrap()
    }

    // Take field
    pub fn take_Due(&mut self) -> TimeStamp {
        self.Due.take().unwrap_or_else(|| TimeStamp::new())
    }

    // bool Ready = 4;


    pub fn get_Ready(&self) -> bool {
        self.Ready
    }
    pub fn clear_Ready(&mut self) {
        self.Ready = false;
    }

    // Param is passed by value, moved
    pub fn set_Ready(&mut self, v: bool) {
        self.Ready = v;
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.Release {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Due {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Release)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Due)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Ready = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Release.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Due.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Ready != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if let Some(ref v) = self.Release.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Due.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Ready != false {
            os.write_bool(4, self.Ready)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Block| { &m.Id },
                    |m: &mut Block| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Release",
                    |m: &Block| { &m.Release },
                    |m: &mut Block| { &mut m.Release },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Due",
                    |m: &Block| { &m.Due },
                    |m: &mut Block| { &mut m.Due },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Ready",
                    |m: &Block| { &m.Ready },
                    |m: &mut Block| { &mut m.Ready },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.Id = 0;
        self.Release.clear();
        self.Due.clear();
        self.Ready = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Crane {
    // message fields
    pub Id: i32,
    pub LocationId: i32,
    pub Load: ::protobuf::SingularPtrField<Block>,
    pub Schedule: ::protobuf::SingularPtrField<CraneSchedule>,
    pub GirderPosition: f64,
    pub HoistPosition: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Crane {
    fn default() -> &'a Crane {
        <Crane as ::protobuf::Message>::default_instance()
    }
}

impl Crane {
    pub fn new() -> Crane {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // int32 LocationId = 2;


    pub fn get_LocationId(&self) -> i32 {
        self.LocationId
    }
    pub fn clear_LocationId(&mut self) {
        self.LocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_LocationId(&mut self, v: i32) {
        self.LocationId = v;
    }

    // .DynStacking.HotStorage.DataModel.Block Load = 3;


    pub fn get_Load(&self) -> &Block {
        self.Load.as_ref().unwrap_or_else(|| Block::default_instance())
    }
    pub fn clear_Load(&mut self) {
        self.Load.clear();
    }

    pub fn has_Load(&self) -> bool {
        self.Load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Load(&mut self, v: Block) {
        self.Load = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Load(&mut self) -> &mut Block {
        if self.Load.is_none() {
            self.Load.set_default();
        }
        self.Load.as_mut().unwrap()
    }

    // Take field
    pub fn take_Load(&mut self) -> Block {
        self.Load.take().unwrap_or_else(|| Block::new())
    }

    // .DynStacking.HotStorage.DataModel.CraneSchedule Schedule = 4;


    pub fn get_Schedule(&self) -> &CraneSchedule {
        self.Schedule.as_ref().unwrap_or_else(|| CraneSchedule::default_instance())
    }
    pub fn clear_Schedule(&mut self) {
        self.Schedule.clear();
    }

    pub fn has_Schedule(&self) -> bool {
        self.Schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Schedule(&mut self, v: CraneSchedule) {
        self.Schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Schedule(&mut self) -> &mut CraneSchedule {
        if self.Schedule.is_none() {
            self.Schedule.set_default();
        }
        self.Schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_Schedule(&mut self) -> CraneSchedule {
        self.Schedule.take().unwrap_or_else(|| CraneSchedule::new())
    }

    // double GirderPosition = 5;


    pub fn get_GirderPosition(&self) -> f64 {
        self.GirderPosition
    }
    pub fn clear_GirderPosition(&mut self) {
        self.GirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_GirderPosition(&mut self, v: f64) {
        self.GirderPosition = v;
    }

    // double HoistPosition = 6;


    pub fn get_HoistPosition(&self) -> f64 {
        self.HoistPosition
    }
    pub fn clear_HoistPosition(&mut self) {
        self.HoistPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_HoistPosition(&mut self, v: f64) {
        self.HoistPosition = v;
    }
}

impl ::protobuf::Message for Crane {
    fn is_initialized(&self) -> bool {
        for v in &self.Load {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.LocationId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Load)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Schedule)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.GirderPosition = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.HoistPosition = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.LocationId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.LocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Load.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.GirderPosition != 0. {
            my_size += 9;
        }
        if self.HoistPosition != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.LocationId != 0 {
            os.write_int32(2, self.LocationId)?;
        }
        if let Some(ref v) = self.Load.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Schedule.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.GirderPosition != 0. {
            os.write_double(5, self.GirderPosition)?;
        }
        if self.HoistPosition != 0. {
            os.write_double(6, self.HoistPosition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Crane {
        Crane::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Crane| { &m.Id },
                    |m: &mut Crane| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "LocationId",
                    |m: &Crane| { &m.LocationId },
                    |m: &mut Crane| { &mut m.LocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "Load",
                    |m: &Crane| { &m.Load },
                    |m: &mut Crane| { &mut m.Load },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneSchedule>>(
                    "Schedule",
                    |m: &Crane| { &m.Schedule },
                    |m: &mut Crane| { &mut m.Schedule },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "GirderPosition",
                    |m: &Crane| { &m.GirderPosition },
                    |m: &mut Crane| { &mut m.GirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HoistPosition",
                    |m: &Crane| { &m.HoistPosition },
                    |m: &mut Crane| { &mut m.HoistPosition },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Crane>(
                    "Crane",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Crane {
        static mut instance: ::protobuf::lazy::Lazy<Crane> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Crane,
        };
        unsafe {
            instance.get(Crane::new)
        }
    }
}

impl ::protobuf::Clear for Crane {
    fn clear(&mut self) {
        self.Id = 0;
        self.LocationId = 0;
        self.Load.clear();
        self.Schedule.clear();
        self.GirderPosition = 0.;
        self.HoistPosition = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Crane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Crane {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneMove {
    // message fields
    pub BlockId: i32,
    pub SourceId: i32,
    pub TargetId: i32,
    pub Sequence: i32,
    pub EmptyMove: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneMove {
    fn default() -> &'a CraneMove {
        <CraneMove as ::protobuf::Message>::default_instance()
    }
}

impl CraneMove {
    pub fn new() -> CraneMove {
        ::std::default::Default::default()
    }

    // int32 BlockId = 1;


    pub fn get_BlockId(&self) -> i32 {
        self.BlockId
    }
    pub fn clear_BlockId(&mut self) {
        self.BlockId = 0;
    }

    // Param is passed by value, moved
    pub fn set_BlockId(&mut self, v: i32) {
        self.BlockId = v;
    }

    // int32 SourceId = 2;


    pub fn get_SourceId(&self) -> i32 {
        self.SourceId
    }
    pub fn clear_SourceId(&mut self) {
        self.SourceId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SourceId(&mut self, v: i32) {
        self.SourceId = v;
    }

    // int32 TargetId = 3;


    pub fn get_TargetId(&self) -> i32 {
        self.TargetId
    }
    pub fn clear_TargetId(&mut self) {
        self.TargetId = 0;
    }

    // Param is passed by value, moved
    pub fn set_TargetId(&mut self, v: i32) {
        self.TargetId = v;
    }

    // int32 Sequence = 4;


    pub fn get_Sequence(&self) -> i32 {
        self.Sequence
    }
    pub fn clear_Sequence(&mut self) {
        self.Sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_Sequence(&mut self, v: i32) {
        self.Sequence = v;
    }

    // bool EmptyMove = 5;


    pub fn get_EmptyMove(&self) -> bool {
        self.EmptyMove
    }
    pub fn clear_EmptyMove(&mut self) {
        self.EmptyMove = false;
    }

    // Param is passed by value, moved
    pub fn set_EmptyMove(&mut self, v: bool) {
        self.EmptyMove = v;
    }
}

impl ::protobuf::Message for CraneMove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.BlockId = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.SourceId = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TargetId = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Sequence = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.EmptyMove = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.BlockId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.BlockId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SourceId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.SourceId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TargetId != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TargetId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Sequence != 0 {
            my_size += ::protobuf::rt::value_size(4, self.Sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EmptyMove != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.BlockId != 0 {
            os.write_int32(1, self.BlockId)?;
        }
        if self.SourceId != 0 {
            os.write_int32(2, self.SourceId)?;
        }
        if self.TargetId != 0 {
            os.write_int32(3, self.TargetId)?;
        }
        if self.Sequence != 0 {
            os.write_int32(4, self.Sequence)?;
        }
        if self.EmptyMove != false {
            os.write_bool(5, self.EmptyMove)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneMove {
        CraneMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "BlockId",
                    |m: &CraneMove| { &m.BlockId },
                    |m: &mut CraneMove| { &mut m.BlockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "SourceId",
                    |m: &CraneMove| { &m.SourceId },
                    |m: &mut CraneMove| { &mut m.SourceId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TargetId",
                    |m: &CraneMove| { &m.TargetId },
                    |m: &mut CraneMove| { &mut m.TargetId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Sequence",
                    |m: &CraneMove| { &m.Sequence },
                    |m: &mut CraneMove| { &mut m.Sequence },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "EmptyMove",
                    |m: &CraneMove| { &m.EmptyMove },
                    |m: &mut CraneMove| { &mut m.EmptyMove },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneMove>(
                    "CraneMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneMove {
        static mut instance: ::protobuf::lazy::Lazy<CraneMove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneMove,
        };
        unsafe {
            instance.get(CraneMove::new)
        }
    }
}

impl ::protobuf::Clear for CraneMove {
    fn clear(&mut self) {
        self.BlockId = 0;
        self.SourceId = 0;
        self.TargetId = 0;
        self.Sequence = 0;
        self.EmptyMove = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneMove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneSchedule {
    // message fields
    pub Moves: ::protobuf::RepeatedField<CraneMove>,
    pub SequenceNr: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneSchedule {
    fn default() -> &'a CraneSchedule {
        <CraneSchedule as ::protobuf::Message>::default_instance()
    }
}

impl CraneSchedule {
    pub fn new() -> CraneSchedule {
        ::std::default::Default::default()
    }

    // repeated .DynStacking.HotStorage.DataModel.CraneMove Moves = 1;


    pub fn get_Moves(&self) -> &[CraneMove] {
        &self.Moves
    }
    pub fn clear_Moves(&mut self) {
        self.Moves.clear();
    }

    // Param is passed by value, moved
    pub fn set_Moves(&mut self, v: ::protobuf::RepeatedField<CraneMove>) {
        self.Moves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Moves(&mut self) -> &mut ::protobuf::RepeatedField<CraneMove> {
        &mut self.Moves
    }

    // Take field
    pub fn take_Moves(&mut self) -> ::protobuf::RepeatedField<CraneMove> {
        ::std::mem::replace(&mut self.Moves, ::protobuf::RepeatedField::new())
    }

    // int32 SequenceNr = 2;


    pub fn get_SequenceNr(&self) -> i32 {
        self.SequenceNr
    }
    pub fn clear_SequenceNr(&mut self) {
        self.SequenceNr = 0;
    }

    // Param is passed by value, moved
    pub fn set_SequenceNr(&mut self, v: i32) {
        self.SequenceNr = v;
    }
}

impl ::protobuf::Message for CraneSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.Moves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Moves)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.SequenceNr = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Moves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.SequenceNr != 0 {
            my_size += ::protobuf::rt::value_size(2, self.SequenceNr, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Moves {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.SequenceNr != 0 {
            os.write_int32(2, self.SequenceNr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneSchedule {
        CraneSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneMove>>(
                    "Moves",
                    |m: &CraneSchedule| { &m.Moves },
                    |m: &mut CraneSchedule| { &mut m.Moves },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "SequenceNr",
                    |m: &CraneSchedule| { &m.SequenceNr },
                    |m: &mut CraneSchedule| { &mut m.SequenceNr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneSchedule>(
                    "CraneSchedule",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneSchedule {
        static mut instance: ::protobuf::lazy::Lazy<CraneSchedule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneSchedule,
        };
        unsafe {
            instance.get(CraneSchedule::new)
        }
    }
}

impl ::protobuf::Clear for CraneSchedule {
    fn clear(&mut self) {
        self.Moves.clear();
        self.SequenceNr = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Handover {
    // message fields
    pub Id: i32,
    pub Ready: bool,
    pub Block: ::protobuf::SingularPtrField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Handover {
    fn default() -> &'a Handover {
        <Handover as ::protobuf::Message>::default_instance()
    }
}

impl Handover {
    pub fn new() -> Handover {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // bool Ready = 2;


    pub fn get_Ready(&self) -> bool {
        self.Ready
    }
    pub fn clear_Ready(&mut self) {
        self.Ready = false;
    }

    // Param is passed by value, moved
    pub fn set_Ready(&mut self, v: bool) {
        self.Ready = v;
    }

    // .DynStacking.HotStorage.DataModel.Block Block = 3;


    pub fn get_Block(&self) -> &Block {
        self.Block.as_ref().unwrap_or_else(|| Block::default_instance())
    }
    pub fn clear_Block(&mut self) {
        self.Block.clear();
    }

    pub fn has_Block(&self) -> bool {
        self.Block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Block(&mut self, v: Block) {
        self.Block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Block(&mut self) -> &mut Block {
        if self.Block.is_none() {
            self.Block.set_default();
        }
        self.Block.as_mut().unwrap()
    }

    // Take field
    pub fn take_Block(&mut self) -> Block {
        self.Block.take().unwrap_or_else(|| Block::new())
    }
}

impl ::protobuf::Message for Handover {
    fn is_initialized(&self) -> bool {
        for v in &self.Block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Ready = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Ready != false {
            my_size += 2;
        }
        if let Some(ref v) = self.Block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.Ready != false {
            os.write_bool(2, self.Ready)?;
        }
        if let Some(ref v) = self.Block.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Handover {
        Handover::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Handover| { &m.Id },
                    |m: &mut Handover| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Ready",
                    |m: &Handover| { &m.Ready },
                    |m: &mut Handover| { &mut m.Ready },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "Block",
                    |m: &Handover| { &m.Block },
                    |m: &mut Handover| { &mut m.Block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Handover>(
                    "Handover",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Handover {
        static mut instance: ::protobuf::lazy::Lazy<Handover> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Handover,
        };
        unsafe {
            instance.get(Handover::new)
        }
    }
}

impl ::protobuf::Clear for Handover {
    fn clear(&mut self) {
        self.Id = 0;
        self.Ready = false;
        self.Block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Handover {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Handover {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Performance {
    // message fields
    pub CraneManipulations: i32,
    pub ServiceLevelMean: f64,
    pub LeadTimeMean: f64,
    pub DeliveredBlocks: i32,
    pub TotalBlocksOnTime: i32,
    pub BlockedArrivalTime: f64,
    pub TardinessMean: f64,
    pub BufferUtilizationMean: f64,
    pub CraneUtilizationMean: f64,
    pub HandoverUtilizationMean: f64,
    pub UpstreamUtilizationMean: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Performance {
    fn default() -> &'a Performance {
        <Performance as ::protobuf::Message>::default_instance()
    }
}

impl Performance {
    pub fn new() -> Performance {
        ::std::default::Default::default()
    }

    // int32 CraneManipulations = 1;


    pub fn get_CraneManipulations(&self) -> i32 {
        self.CraneManipulations
    }
    pub fn clear_CraneManipulations(&mut self) {
        self.CraneManipulations = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneManipulations(&mut self, v: i32) {
        self.CraneManipulations = v;
    }

    // double ServiceLevelMean = 2;


    pub fn get_ServiceLevelMean(&self) -> f64 {
        self.ServiceLevelMean
    }
    pub fn clear_ServiceLevelMean(&mut self) {
        self.ServiceLevelMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ServiceLevelMean(&mut self, v: f64) {
        self.ServiceLevelMean = v;
    }

    // double LeadTimeMean = 3;


    pub fn get_LeadTimeMean(&self) -> f64 {
        self.LeadTimeMean
    }
    pub fn clear_LeadTimeMean(&mut self) {
        self.LeadTimeMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_LeadTimeMean(&mut self, v: f64) {
        self.LeadTimeMean = v;
    }

    // int32 DeliveredBlocks = 4;


    pub fn get_DeliveredBlocks(&self) -> i32 {
        self.DeliveredBlocks
    }
    pub fn clear_DeliveredBlocks(&mut self) {
        self.DeliveredBlocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_DeliveredBlocks(&mut self, v: i32) {
        self.DeliveredBlocks = v;
    }

    // int32 TotalBlocksOnTime = 5;


    pub fn get_TotalBlocksOnTime(&self) -> i32 {
        self.TotalBlocksOnTime
    }
    pub fn clear_TotalBlocksOnTime(&mut self) {
        self.TotalBlocksOnTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalBlocksOnTime(&mut self, v: i32) {
        self.TotalBlocksOnTime = v;
    }

    // double BlockedArrivalTime = 6;


    pub fn get_BlockedArrivalTime(&self) -> f64 {
        self.BlockedArrivalTime
    }
    pub fn clear_BlockedArrivalTime(&mut self) {
        self.BlockedArrivalTime = 0.;
    }

    // Param is passed by value, moved
    pub fn set_BlockedArrivalTime(&mut self, v: f64) {
        self.BlockedArrivalTime = v;
    }

    // double TardinessMean = 7;


    pub fn get_TardinessMean(&self) -> f64 {
        self.TardinessMean
    }
    pub fn clear_TardinessMean(&mut self) {
        self.TardinessMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_TardinessMean(&mut self, v: f64) {
        self.TardinessMean = v;
    }

    // double BufferUtilizationMean = 8;


    pub fn get_BufferUtilizationMean(&self) -> f64 {
        self.BufferUtilizationMean
    }
    pub fn clear_BufferUtilizationMean(&mut self) {
        self.BufferUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_BufferUtilizationMean(&mut self, v: f64) {
        self.BufferUtilizationMean = v;
    }

    // double CraneUtilizationMean = 9;


    pub fn get_CraneUtilizationMean(&self) -> f64 {
        self.CraneUtilizationMean
    }
    pub fn clear_CraneUtilizationMean(&mut self) {
        self.CraneUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_CraneUtilizationMean(&mut self, v: f64) {
        self.CraneUtilizationMean = v;
    }

    // double HandoverUtilizationMean = 10;


    pub fn get_HandoverUtilizationMean(&self) -> f64 {
        self.HandoverUtilizationMean
    }
    pub fn clear_HandoverUtilizationMean(&mut self) {
        self.HandoverUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_HandoverUtilizationMean(&mut self, v: f64) {
        self.HandoverUtilizationMean = v;
    }

    // double UpstreamUtilizationMean = 11;


    pub fn get_UpstreamUtilizationMean(&self) -> f64 {
        self.UpstreamUtilizationMean
    }
    pub fn clear_UpstreamUtilizationMean(&mut self) {
        self.UpstreamUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_UpstreamUtilizationMean(&mut self, v: f64) {
        self.UpstreamUtilizationMean = v;
    }
}

impl ::protobuf::Message for Performance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneManipulations = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ServiceLevelMean = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.LeadTimeMean = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DeliveredBlocks = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TotalBlocksOnTime = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.BlockedArrivalTime = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.TardinessMean = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.BufferUtilizationMean = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.CraneUtilizationMean = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.HandoverUtilizationMean = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.UpstreamUtilizationMean = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.CraneManipulations != 0 {
            my_size += ::protobuf::rt::value_size(1, self.CraneManipulations, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ServiceLevelMean != 0. {
            my_size += 9;
        }
        if self.LeadTimeMean != 0. {
            my_size += 9;
        }
        if self.DeliveredBlocks != 0 {
            my_size += ::protobuf::rt::value_size(4, self.DeliveredBlocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalBlocksOnTime != 0 {
            my_size += ::protobuf::rt::value_size(5, self.TotalBlocksOnTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BlockedArrivalTime != 0. {
            my_size += 9;
        }
        if self.TardinessMean != 0. {
            my_size += 9;
        }
        if self.BufferUtilizationMean != 0. {
            my_size += 9;
        }
        if self.CraneUtilizationMean != 0. {
            my_size += 9;
        }
        if self.HandoverUtilizationMean != 0. {
            my_size += 9;
        }
        if self.UpstreamUtilizationMean != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.CraneManipulations != 0 {
            os.write_int32(1, self.CraneManipulations)?;
        }
        if self.ServiceLevelMean != 0. {
            os.write_double(2, self.ServiceLevelMean)?;
        }
        if self.LeadTimeMean != 0. {
            os.write_double(3, self.LeadTimeMean)?;
        }
        if self.DeliveredBlocks != 0 {
            os.write_int32(4, self.DeliveredBlocks)?;
        }
        if self.TotalBlocksOnTime != 0 {
            os.write_int32(5, self.TotalBlocksOnTime)?;
        }
        if self.BlockedArrivalTime != 0. {
            os.write_double(6, self.BlockedArrivalTime)?;
        }
        if self.TardinessMean != 0. {
            os.write_double(7, self.TardinessMean)?;
        }
        if self.BufferUtilizationMean != 0. {
            os.write_double(8, self.BufferUtilizationMean)?;
        }
        if self.CraneUtilizationMean != 0. {
            os.write_double(9, self.CraneUtilizationMean)?;
        }
        if self.HandoverUtilizationMean != 0. {
            os.write_double(10, self.HandoverUtilizationMean)?;
        }
        if self.UpstreamUtilizationMean != 0. {
            os.write_double(11, self.UpstreamUtilizationMean)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Performance {
        Performance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneManipulations",
                    |m: &Performance| { &m.CraneManipulations },
                    |m: &mut Performance| { &mut m.CraneManipulations },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ServiceLevelMean",
                    |m: &Performance| { &m.ServiceLevelMean },
                    |m: &mut Performance| { &mut m.ServiceLevelMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "LeadTimeMean",
                    |m: &Performance| { &m.LeadTimeMean },
                    |m: &mut Performance| { &mut m.LeadTimeMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DeliveredBlocks",
                    |m: &Performance| { &m.DeliveredBlocks },
                    |m: &mut Performance| { &mut m.DeliveredBlocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TotalBlocksOnTime",
                    |m: &Performance| { &m.TotalBlocksOnTime },
                    |m: &mut Performance| { &mut m.TotalBlocksOnTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "BlockedArrivalTime",
                    |m: &Performance| { &m.BlockedArrivalTime },
                    |m: &mut Performance| { &mut m.BlockedArrivalTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "TardinessMean",
                    |m: &Performance| { &m.TardinessMean },
                    |m: &mut Performance| { &mut m.TardinessMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "BufferUtilizationMean",
                    |m: &Performance| { &m.BufferUtilizationMean },
                    |m: &mut Performance| { &mut m.BufferUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "CraneUtilizationMean",
                    |m: &Performance| { &m.CraneUtilizationMean },
                    |m: &mut Performance| { &mut m.CraneUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HandoverUtilizationMean",
                    |m: &Performance| { &m.HandoverUtilizationMean },
                    |m: &mut Performance| { &mut m.HandoverUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "UpstreamUtilizationMean",
                    |m: &Performance| { &m.UpstreamUtilizationMean },
                    |m: &mut Performance| { &mut m.UpstreamUtilizationMean },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Performance>(
                    "Performance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Performance {
        static mut instance: ::protobuf::lazy::Lazy<Performance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Performance,
        };
        unsafe {
            instance.get(Performance::new)
        }
    }
}

impl ::protobuf::Clear for Performance {
    fn clear(&mut self) {
        self.CraneManipulations = 0;
        self.ServiceLevelMean = 0.;
        self.LeadTimeMean = 0.;
        self.DeliveredBlocks = 0;
        self.TotalBlocksOnTime = 0;
        self.BlockedArrivalTime = 0.;
        self.TardinessMean = 0.;
        self.BufferUtilizationMean = 0.;
        self.CraneUtilizationMean = 0.;
        self.HandoverUtilizationMean = 0.;
        self.UpstreamUtilizationMean = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Performance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Performance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stack {
    // message fields
    pub Id: i32,
    pub MaxHeight: i32,
    pub BottomToTop: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stack {
    fn default() -> &'a Stack {
        <Stack as ::protobuf::Message>::default_instance()
    }
}

impl Stack {
    pub fn new() -> Stack {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // int32 MaxHeight = 2;


    pub fn get_MaxHeight(&self) -> i32 {
        self.MaxHeight
    }
    pub fn clear_MaxHeight(&mut self) {
        self.MaxHeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_MaxHeight(&mut self, v: i32) {
        self.MaxHeight = v;
    }

    // repeated .DynStacking.HotStorage.DataModel.Block BottomToTop = 3;


    pub fn get_BottomToTop(&self) -> &[Block] {
        &self.BottomToTop
    }
    pub fn clear_BottomToTop(&mut self) {
        self.BottomToTop.clear();
    }

    // Param is passed by value, moved
    pub fn set_BottomToTop(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.BottomToTop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BottomToTop(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.BottomToTop
    }

    // Take field
    pub fn take_BottomToTop(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.BottomToTop, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Stack {
    fn is_initialized(&self) -> bool {
        for v in &self.BottomToTop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.MaxHeight = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.BottomToTop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MaxHeight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.MaxHeight, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.BottomToTop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.MaxHeight != 0 {
            os.write_int32(2, self.MaxHeight)?;
        }
        for v in &self.BottomToTop {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stack {
        Stack::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Stack| { &m.Id },
                    |m: &mut Stack| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "MaxHeight",
                    |m: &Stack| { &m.MaxHeight },
                    |m: &mut Stack| { &mut m.MaxHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "BottomToTop",
                    |m: &Stack| { &m.BottomToTop },
                    |m: &mut Stack| { &mut m.BottomToTop },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stack>(
                    "Stack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Stack {
        static mut instance: ::protobuf::lazy::Lazy<Stack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Stack,
        };
        unsafe {
            instance.get(Stack::new)
        }
    }
}

impl ::protobuf::Clear for Stack {
    fn clear(&mut self) {
        self.Id = 0;
        self.MaxHeight = 0;
        self.BottomToTop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeStamp {
    // message fields
    pub MilliSeconds: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeStamp {
    fn default() -> &'a TimeStamp {
        <TimeStamp as ::protobuf::Message>::default_instance()
    }
}

impl TimeStamp {
    pub fn new() -> TimeStamp {
        ::std::default::Default::default()
    }

    // int64 MilliSeconds = 1;


    pub fn get_MilliSeconds(&self) -> i64 {
        self.MilliSeconds
    }
    pub fn clear_MilliSeconds(&mut self) {
        self.MilliSeconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_MilliSeconds(&mut self, v: i64) {
        self.MilliSeconds = v;
    }
}

impl ::protobuf::Message for TimeStamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.MilliSeconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.MilliSeconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.MilliSeconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.MilliSeconds != 0 {
            os.write_int64(1, self.MilliSeconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeStamp {
        TimeStamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "MilliSeconds",
                    |m: &TimeStamp| { &m.MilliSeconds },
                    |m: &mut TimeStamp| { &mut m.MilliSeconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeStamp>(
                    "TimeStamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeStamp {
        static mut instance: ::protobuf::lazy::Lazy<TimeStamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeStamp,
        };
        unsafe {
            instance.get(TimeStamp::new)
        }
    }
}

impl ::protobuf::Clear for TimeStamp {
    fn clear(&mut self) {
        self.MilliSeconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeStamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uncertainties {
    // message fields
    pub ArrivalIntervals: ::std::vec::Vec<f64>,
    pub CraneMoveTimes: ::std::vec::Vec<f64>,
    pub HandoverReadyIntervals: ::std::vec::Vec<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Uncertainties {
    fn default() -> &'a Uncertainties {
        <Uncertainties as ::protobuf::Message>::default_instance()
    }
}

impl Uncertainties {
    pub fn new() -> Uncertainties {
        ::std::default::Default::default()
    }

    // repeated double ArrivalIntervals = 1;


    pub fn get_ArrivalIntervals(&self) -> &[f64] {
        &self.ArrivalIntervals
    }
    pub fn clear_ArrivalIntervals(&mut self) {
        self.ArrivalIntervals.clear();
    }

    // Param is passed by value, moved
    pub fn set_ArrivalIntervals(&mut self, v: ::std::vec::Vec<f64>) {
        self.ArrivalIntervals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ArrivalIntervals(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.ArrivalIntervals
    }

    // Take field
    pub fn take_ArrivalIntervals(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.ArrivalIntervals, ::std::vec::Vec::new())
    }

    // repeated double CraneMoveTimes = 2;


    pub fn get_CraneMoveTimes(&self) -> &[f64] {
        &self.CraneMoveTimes
    }
    pub fn clear_CraneMoveTimes(&mut self) {
        self.CraneMoveTimes.clear();
    }

    // Param is passed by value, moved
    pub fn set_CraneMoveTimes(&mut self, v: ::std::vec::Vec<f64>) {
        self.CraneMoveTimes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CraneMoveTimes(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.CraneMoveTimes
    }

    // Take field
    pub fn take_CraneMoveTimes(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.CraneMoveTimes, ::std::vec::Vec::new())
    }

    // repeated double HandoverReadyIntervals = 3;


    pub fn get_HandoverReadyIntervals(&self) -> &[f64] {
        &self.HandoverReadyIntervals
    }
    pub fn clear_HandoverReadyIntervals(&mut self) {
        self.HandoverReadyIntervals.clear();
    }

    // Param is passed by value, moved
    pub fn set_HandoverReadyIntervals(&mut self, v: ::std::vec::Vec<f64>) {
        self.HandoverReadyIntervals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HandoverReadyIntervals(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.HandoverReadyIntervals
    }

    // Take field
    pub fn take_HandoverReadyIntervals(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.HandoverReadyIntervals, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Uncertainties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.ArrivalIntervals)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.CraneMoveTimes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.HandoverReadyIntervals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.ArrivalIntervals.len() as u32;
        my_size += 9 * self.CraneMoveTimes.len() as u32;
        my_size += 9 * self.HandoverReadyIntervals.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ArrivalIntervals {
            os.write_double(1, *v)?;
        };
        for v in &self.CraneMoveTimes {
            os.write_double(2, *v)?;
        };
        for v in &self.HandoverReadyIntervals {
            os.write_double(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uncertainties {
        Uncertainties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ArrivalIntervals",
                    |m: &Uncertainties| { &m.ArrivalIntervals },
                    |m: &mut Uncertainties| { &mut m.ArrivalIntervals },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "CraneMoveTimes",
                    |m: &Uncertainties| { &m.CraneMoveTimes },
                    |m: &mut Uncertainties| { &mut m.CraneMoveTimes },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HandoverReadyIntervals",
                    |m: &Uncertainties| { &m.HandoverReadyIntervals },
                    |m: &mut Uncertainties| { &mut m.HandoverReadyIntervals },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uncertainties>(
                    "Uncertainties",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uncertainties {
        static mut instance: ::protobuf::lazy::Lazy<Uncertainties> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uncertainties,
        };
        unsafe {
            instance.get(Uncertainties::new)
        }
    }
}

impl ::protobuf::Clear for Uncertainties {
    fn clear(&mut self) {
        self.ArrivalIntervals.clear();
        self.CraneMoveTimes.clear();
        self.HandoverReadyIntervals.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uncertainties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uncertainties {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct World {
    // message fields
    pub Now: ::protobuf::SingularPtrField<TimeStamp>,
    pub Production: ::protobuf::SingularPtrField<Stack>,
    pub Buffers: ::protobuf::RepeatedField<Stack>,
    pub Handover: ::protobuf::SingularPtrField<Handover>,
    pub Crane: ::protobuf::SingularPtrField<Crane>,
    pub KPIs: ::protobuf::SingularPtrField<Performance>,
    pub ObservationData: ::protobuf::SingularPtrField<Uncertainties>,
    pub InvalidMoves: ::protobuf::RepeatedField<CraneMove>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a World {
    fn default() -> &'a World {
        <World as ::protobuf::Message>::default_instance()
    }
}

impl World {
    pub fn new() -> World {
        ::std::default::Default::default()
    }

    // .DynStacking.HotStorage.DataModel.TimeStamp Now = 1;


    pub fn get_Now(&self) -> &TimeStamp {
        self.Now.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Now(&mut self) {
        self.Now.clear();
    }

    pub fn has_Now(&self) -> bool {
        self.Now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Now(&mut self, v: TimeStamp) {
        self.Now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Now(&mut self) -> &mut TimeStamp {
        if self.Now.is_none() {
            self.Now.set_default();
        }
        self.Now.as_mut().unwrap()
    }

    // Take field
    pub fn take_Now(&mut self) -> TimeStamp {
        self.Now.take().unwrap_or_else(|| TimeStamp::new())
    }

    // .DynStacking.HotStorage.DataModel.Stack Production = 2;


    pub fn get_Production(&self) -> &Stack {
        self.Production.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Production(&mut self) {
        self.Production.clear();
    }

    pub fn has_Production(&self) -> bool {
        self.Production.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Production(&mut self, v: Stack) {
        self.Production = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Production(&mut self) -> &mut Stack {
        if self.Production.is_none() {
            self.Production.set_default();
        }
        self.Production.as_mut().unwrap()
    }

    // Take field
    pub fn take_Production(&mut self) -> Stack {
        self.Production.take().unwrap_or_else(|| Stack::new())
    }

    // repeated .DynStacking.HotStorage.DataModel.Stack Buffers = 3;


    pub fn get_Buffers(&self) -> &[Stack] {
        &self.Buffers
    }
    pub fn clear_Buffers(&mut self) {
        self.Buffers.clear();
    }

    // Param is passed by value, moved
    pub fn set_Buffers(&mut self, v: ::protobuf::RepeatedField<Stack>) {
        self.Buffers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Buffers(&mut self) -> &mut ::protobuf::RepeatedField<Stack> {
        &mut self.Buffers
    }

    // Take field
    pub fn take_Buffers(&mut self) -> ::protobuf::RepeatedField<Stack> {
        ::std::mem::replace(&mut self.Buffers, ::protobuf::RepeatedField::new())
    }

    // .DynStacking.HotStorage.DataModel.Handover Handover = 4;


    pub fn get_Handover(&self) -> &Handover {
        self.Handover.as_ref().unwrap_or_else(|| Handover::default_instance())
    }
    pub fn clear_Handover(&mut self) {
        self.Handover.clear();
    }

    pub fn has_Handover(&self) -> bool {
        self.Handover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Handover(&mut self, v: Handover) {
        self.Handover = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Handover(&mut self) -> &mut Handover {
        if self.Handover.is_none() {
            self.Handover.set_default();
        }
        self.Handover.as_mut().unwrap()
    }

    // Take field
    pub fn take_Handover(&mut self) -> Handover {
        self.Handover.take().unwrap_or_else(|| Handover::new())
    }

    // .DynStacking.HotStorage.DataModel.Crane Crane = 5;


    pub fn get_Crane(&self) -> &Crane {
        self.Crane.as_ref().unwrap_or_else(|| Crane::default_instance())
    }
    pub fn clear_Crane(&mut self) {
        self.Crane.clear();
    }

    pub fn has_Crane(&self) -> bool {
        self.Crane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Crane(&mut self, v: Crane) {
        self.Crane = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Crane(&mut self) -> &mut Crane {
        if self.Crane.is_none() {
            self.Crane.set_default();
        }
        self.Crane.as_mut().unwrap()
    }

    // Take field
    pub fn take_Crane(&mut self) -> Crane {
        self.Crane.take().unwrap_or_else(|| Crane::new())
    }

    // .DynStacking.HotStorage.DataModel.Performance KPIs = 6;


    pub fn get_KPIs(&self) -> &Performance {
        self.KPIs.as_ref().unwrap_or_else(|| Performance::default_instance())
    }
    pub fn clear_KPIs(&mut self) {
        self.KPIs.clear();
    }

    pub fn has_KPIs(&self) -> bool {
        self.KPIs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_KPIs(&mut self, v: Performance) {
        self.KPIs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_KPIs(&mut self) -> &mut Performance {
        if self.KPIs.is_none() {
            self.KPIs.set_default();
        }
        self.KPIs.as_mut().unwrap()
    }

    // Take field
    pub fn take_KPIs(&mut self) -> Performance {
        self.KPIs.take().unwrap_or_else(|| Performance::new())
    }

    // .DynStacking.HotStorage.DataModel.Uncertainties ObservationData = 7;


    pub fn get_ObservationData(&self) -> &Uncertainties {
        self.ObservationData.as_ref().unwrap_or_else(|| Uncertainties::default_instance())
    }
    pub fn clear_ObservationData(&mut self) {
        self.ObservationData.clear();
    }

    pub fn has_ObservationData(&self) -> bool {
        self.ObservationData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ObservationData(&mut self, v: Uncertainties) {
        self.ObservationData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ObservationData(&mut self) -> &mut Uncertainties {
        if self.ObservationData.is_none() {
            self.ObservationData.set_default();
        }
        self.ObservationData.as_mut().unwrap()
    }

    // Take field
    pub fn take_ObservationData(&mut self) -> Uncertainties {
        self.ObservationData.take().unwrap_or_else(|| Uncertainties::new())
    }

    // repeated .DynStacking.HotStorage.DataModel.CraneMove InvalidMoves = 8;


    pub fn get_InvalidMoves(&self) -> &[CraneMove] {
        &self.InvalidMoves
    }
    pub fn clear_InvalidMoves(&mut self) {
        self.InvalidMoves.clear();
    }

    // Param is passed by value, moved
    pub fn set_InvalidMoves(&mut self, v: ::protobuf::RepeatedField<CraneMove>) {
        self.InvalidMoves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_InvalidMoves(&mut self) -> &mut ::protobuf::RepeatedField<CraneMove> {
        &mut self.InvalidMoves
    }

    // Take field
    pub fn take_InvalidMoves(&mut self) -> ::protobuf::RepeatedField<CraneMove> {
        ::std::mem::replace(&mut self.InvalidMoves, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for World {
    fn is_initialized(&self) -> bool {
        for v in &self.Now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Production {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Buffers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Handover {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Crane {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.KPIs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ObservationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.InvalidMoves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Now)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Production)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Buffers)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Handover)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Crane)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.KPIs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ObservationData)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.InvalidMoves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Production.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Handover.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Crane.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ObservationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.InvalidMoves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Now.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Production.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.Buffers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Handover.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Crane.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ObservationData.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.InvalidMoves {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> World {
        World::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Now",
                    |m: &World| { &m.Now },
                    |m: &mut World| { &mut m.Now },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Production",
                    |m: &World| { &m.Production },
                    |m: &mut World| { &mut m.Production },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Buffers",
                    |m: &World| { &m.Buffers },
                    |m: &mut World| { &mut m.Buffers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handover>>(
                    "Handover",
                    |m: &World| { &m.Handover },
                    |m: &mut World| { &mut m.Handover },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Crane>>(
                    "Crane",
                    |m: &World| { &m.Crane },
                    |m: &mut World| { &mut m.Crane },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Performance>>(
                    "KPIs",
                    |m: &World| { &m.KPIs },
                    |m: &mut World| { &mut m.KPIs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uncertainties>>(
                    "ObservationData",
                    |m: &World| { &m.ObservationData },
                    |m: &mut World| { &mut m.ObservationData },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneMove>>(
                    "InvalidMoves",
                    |m: &World| { &m.InvalidMoves },
                    |m: &mut World| { &mut m.InvalidMoves },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<World>(
                    "World",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static World {
        static mut instance: ::protobuf::lazy::Lazy<World> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const World,
        };
        unsafe {
            instance.get(World::new)
        }
    }
}

impl ::protobuf::Clear for World {
    fn clear(&mut self) {
        self.Now.clear();
        self.Production.clear();
        self.Buffers.clear();
        self.Handover.clear();
        self.Crane.clear();
        self.KPIs.clear();
        self.ObservationData.clear();
        self.InvalidMoves.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for World {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for World {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16hotstorage_model.proto\x12\x20DynStacking.HotStorage.DataModel\"\
    \xb3\x01\n\x05Block\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12E\n\
    \x07Release\x18\x02\x20\x01(\x0b2+.DynStacking.HotStorage.DataModel.Time\
    StampR\x07Release\x12=\n\x03Due\x18\x03\x20\x01(\x0b2+.DynStacking.HotSt\
    orage.DataModel.TimeStampR\x03Due\x12\x14\n\x05Ready\x18\x04\x20\x01(\
    \x08R\x05Ready\"\x8f\x02\n\x05Crane\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05\
    R\x02Id\x12\x1e\n\nLocationId\x18\x02\x20\x01(\x05R\nLocationId\x12;\n\
    \x04Load\x18\x03\x20\x01(\x0b2'.DynStacking.HotStorage.DataModel.BlockR\
    \x04Load\x12K\n\x08Schedule\x18\x04\x20\x01(\x0b2/.DynStacking.HotStorag\
    e.DataModel.CraneScheduleR\x08Schedule\x12&\n\x0eGirderPosition\x18\x05\
    \x20\x01(\x01R\x0eGirderPosition\x12$\n\rHoistPosition\x18\x06\x20\x01(\
    \x01R\rHoistPosition\"\x97\x01\n\tCraneMove\x12\x18\n\x07BlockId\x18\x01\
    \x20\x01(\x05R\x07BlockId\x12\x1a\n\x08SourceId\x18\x02\x20\x01(\x05R\
    \x08SourceId\x12\x1a\n\x08TargetId\x18\x03\x20\x01(\x05R\x08TargetId\x12\
    \x1a\n\x08Sequence\x18\x04\x20\x01(\x05R\x08Sequence\x12\x1c\n\tEmptyMov\
    e\x18\x05\x20\x01(\x08R\tEmptyMove\"r\n\rCraneSchedule\x12A\n\x05Moves\
    \x18\x01\x20\x03(\x0b2+.DynStacking.HotStorage.DataModel.CraneMoveR\x05M\
    oves\x12\x1e\n\nSequenceNr\x18\x02\x20\x01(\x05R\nSequenceNr\"o\n\x08Han\
    dover\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12\x14\n\x05Ready\x18\
    \x02\x20\x01(\x08R\x05Ready\x12=\n\x05Block\x18\x03\x20\x01(\x0b2'.DynSt\
    acking.HotStorage.DataModel.BlockR\x05Block\"\x99\x04\n\x0bPerformance\
    \x12.\n\x12CraneManipulations\x18\x01\x20\x01(\x05R\x12CraneManipulation\
    s\x12*\n\x10ServiceLevelMean\x18\x02\x20\x01(\x01R\x10ServiceLevelMean\
    \x12\"\n\x0cLeadTimeMean\x18\x03\x20\x01(\x01R\x0cLeadTimeMean\x12(\n\
    \x0fDeliveredBlocks\x18\x04\x20\x01(\x05R\x0fDeliveredBlocks\x12,\n\x11T\
    otalBlocksOnTime\x18\x05\x20\x01(\x05R\x11TotalBlocksOnTime\x12.\n\x12Bl\
    ockedArrivalTime\x18\x06\x20\x01(\x01R\x12BlockedArrivalTime\x12$\n\rTar\
    dinessMean\x18\x07\x20\x01(\x01R\rTardinessMean\x124\n\x15BufferUtilizat\
    ionMean\x18\x08\x20\x01(\x01R\x15BufferUtilizationMean\x122\n\x14CraneUt\
    ilizationMean\x18\t\x20\x01(\x01R\x14CraneUtilizationMean\x128\n\x17Hand\
    overUtilizationMean\x18\n\x20\x01(\x01R\x17HandoverUtilizationMean\x128\
    \n\x17UpstreamUtilizationMean\x18\x0b\x20\x01(\x01R\x17UpstreamUtilizati\
    onMean\"\x80\x01\n\x05Stack\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\
    \x12\x1c\n\tMaxHeight\x18\x02\x20\x01(\x05R\tMaxHeight\x12I\n\x0bBottomT\
    oTop\x18\x03\x20\x03(\x0b2'.DynStacking.HotStorage.DataModel.BlockR\x0bB\
    ottomToTop\"/\n\tTimeStamp\x12\"\n\x0cMilliSeconds\x18\x01\x20\x01(\x03R\
    \x0cMilliSeconds\"\xa7\x01\n\rUncertainties\x12.\n\x10ArrivalIntervals\
    \x18\x01\x20\x03(\x01R\x10ArrivalIntervalsB\x02\x10\0\x12*\n\x0eCraneMov\
    eTimes\x18\x02\x20\x03(\x01R\x0eCraneMoveTimesB\x02\x10\0\x12:\n\x16Hand\
    overReadyIntervals\x18\x03\x20\x03(\x01R\x16HandoverReadyIntervalsB\x02\
    \x10\0\"\xc8\x04\n\x05World\x12=\n\x03Now\x18\x01\x20\x01(\x0b2+.DynStac\
    king.HotStorage.DataModel.TimeStampR\x03Now\x12G\n\nProduction\x18\x02\
    \x20\x01(\x0b2'.DynStacking.HotStorage.DataModel.StackR\nProduction\x12A\
    \n\x07Buffers\x18\x03\x20\x03(\x0b2'.DynStacking.HotStorage.DataModel.St\
    ackR\x07Buffers\x12F\n\x08Handover\x18\x04\x20\x01(\x0b2*.DynStacking.Ho\
    tStorage.DataModel.HandoverR\x08Handover\x12=\n\x05Crane\x18\x05\x20\x01\
    (\x0b2'.DynStacking.HotStorage.DataModel.CraneR\x05Crane\x12A\n\x04KPIs\
    \x18\x06\x20\x01(\x0b2-.DynStacking.HotStorage.DataModel.PerformanceR\
    \x04KPIs\x12Y\n\x0fObservationData\x18\x07\x20\x01(\x0b2/.DynStacking.Ho\
    tStorage.DataModel.UncertaintiesR\x0fObservationData\x12O\n\x0cInvalidMo\
    ves\x18\x08\x20\x03(\x0b2+.DynStacking.HotStorage.DataModel.CraneMoveR\
    \x0cInvalidMovesb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
